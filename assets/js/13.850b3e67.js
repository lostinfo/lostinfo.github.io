(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{67:function(t,n,e){"use strict";e.r(n);var a=e(0),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、channel关闭规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、channel关闭规则"}},[t._v("#")]),t._v(" 一、channel关闭规则")]),t._v(" "),e("ul",[e("li",[t._v("不要从接收端关闭channel。")]),t._v(" "),e("li",[t._v("也不要关闭有多个并发发送者的channel。")])]),t._v(" "),e("p",[t._v("换句话说,如果sender(发送者)只是唯一的sender或者是channel最后一个活跃的sender,那么你应该在sender的goroutine关闭channel,从而通知receiver(s)(接收者们)已经没有值可以读了。维持这条原则将保证永远不会发生向一个已经关闭的channel发送值或者关闭一个已经关闭的channel。")]),t._v(" "),e("h2",{attrs:{id:"二、代码实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、代码实现"}},[t._v("#")]),t._v(" 二、代码实现")]),t._v(" "),e("ul",[e("li",[t._v("一个生产者,多个消费者,这是最简单的场景了，就只是当生产者不想再发送的时候让生产者关闭data的channel")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport (\n\t"log"\n\t"math/rand"\n\t"sync"\n\t"time"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tlog.SetFlags(0)\n\n\t// ...\n\tconst MaxRandomNumber = 100000\n\tconst NumReceivers = 100\n\n\twgReceivers := sync.WaitGroup{}\n\twgReceivers.Add(NumReceivers)\n\n\t// ...\n\tdataCh := make(chan int, 100)\n\n\t// the producer\n\tgo func() {\n\t\tfor {\n\t\t\tif value := rand.Intn(MaxRandomNumber); value == 0 {\n\t\t\t\t// the only sender can close the channel safely.\n\t\t\t\tclose(dataCh)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tdataCh <- value\n\t\t\t}\n\t\t}\n\t}()\n\n\t// the comsumer\n\tfor i := 0; i < NumReceivers; i++ {\n\t\tgo func() {\n\t\t\tdefer wgReceivers.Done()\n\n\t\t\t// receive values until dataCh is closed and\n\t\t\t// the value buffer queue of dataCh is empty.\n\t\t\tfor value := range dataCh {\n\t\t\t\tlog.Println(value)\n\t\t\t}\n\t\t}()\n\t}\n\n\twgReceivers.Wait()\n}\n')])])]),e("ul",[e("li",[t._v("一个消费者，多个生产者,消费者通过关闭一个额外的signal channel说“请停止发送”")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport (\n\t"log"\n\t"math/rand"\n\t"sync"\n\t"time"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tlog.SetFlags(0)\n\n\t// ...\n\tconst MaxRandomNumber = 100000\n\tconst NumSenders = 1000\n\n\twgReceivers := sync.WaitGroup{}\n\twgReceivers.Add(1)\n\n\t// ...\n\tdataCh := make(chan int, 100)\n\tstopCh := make(chan struct{})\n\t// stopCh is an additional signal channel.\n\t// Its sender is the receiver of channel dataCh.\n\t// Its reveivers are the senders of channel dataCh.\n\n\t// senders\n\tfor i := 0; i < NumSenders; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tvalue := rand.Intn(MaxRandomNumber)\n\n\t\t\t\tselect {\n\t\t\t\tcase <-stopCh:\n\t\t\t\t\treturn\n\t\t\t\tcase dataCh <- value:\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t// the receiver\n\tgo func() {\n\t\tdefer wgReceivers.Done()\n\n\t\tfor value := range dataCh {\n\t\t\tif value == MaxRandomNumber-1 {\n\t\t\t\t// the receiver of the dataCh channel is\n\t\t\t\t// also the sender of the stopCh cahnnel.\n\t\t\t\t// It is safe to close the stop channel here.\n\t\t\t\tclose(stopCh)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlog.Println(value)\n\t\t}\n\t}()\n\n\t// ...\n\twgReceivers.Wait()\n}\n')])])]),e("ul",[e("li",[t._v("多个消费者，多个生产者，它们当中任意一个通过通知一个moderator(仲裁者)关闭额外的signal channel来说“让我们结束游戏吧”")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n\nimport (\n\t"log"\n\t"math/rand"\n\t"strconv"\n\t"sync"\n\t"time"\n)\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tlog.SetFlags(0)\n\n\t// ...\n\tconst MaxRandomNumber = 100000\n\tconst NumReceivers = 10\n\tconst NumSenders = 1000\n\n\twgReceivers := sync.WaitGroup{}\n\twgReceivers.Add(NumReceivers)\n\n\t// ...\n\tdataCh := make(chan int, 100)\n\tstopCh := make(chan struct{})\n\t// stopCh is an additional signal channel.\n\t// Its sender is the moderator goroutine shown below.\n\t// Its reveivers are all senders and receivers of dataCh.\n\ttoStop := make(chan string, 1)\n\t// the channel toStop is used to notify the moderator\n\t// to close the additional signal channel (stopCh).\n\t// Its senders are any senders and receivers of dataCh.\n\t// Its reveiver is the moderator goroutine shown below.\n\n\tvar stoppedBy string\n\n\t// moderator\n\tgo func() {\n\t\tstoppedBy = <-toStop // part of the trick used to notify the moderator\n\t\t// to close the additional signal channel.\n\t\tclose(stopCh)\n\t}()\n\n\t// producer\n\tfor i := 0; i < NumSenders; i++ {\n\t\tgo func(id string) {\n\t\t\tfor {\n\t\t\t\tvalue := rand.Intn(MaxRandomNumber)\n\t\t\t\tif value == 0 {\n\t\t\t\t\t// here, a trick is used to notify the moderator\n\t\t\t\t\t// to close the additional signal channel.\n\t\t\t\t\tselect {\n\t\t\t\t\tcase toStop <- "sender#" + id:\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// the first select here is to try to exit the\n\t\t\t\t// goroutine as early as possible.\n\t\t\t\tselect {\n\t\t\t\tcase <-stopCh:\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase <-stopCh:\n\t\t\t\t\treturn\n\t\t\t\tcase dataCh <- value:\n\t\t\t\t}\n\t\t\t}\n\t\t}(strconv.Itoa(i))\n\t}\n\n\t// comsumer\n\tfor i := 0; i < NumReceivers; i++ {\n\t\tgo func(id string) {\n\t\t\tdefer wgReceivers.Done()\n\n\t\t\tfor {\n\t\t\t\t// same as senders, the first select here is to \n\t\t\t\t// try to exit the goroutine as early as possible.\n\t\t\t\tselect {\n\t\t\t\tcase <-stopCh:\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase <-stopCh:\n\t\t\t\t\treturn\n\t\t\t\tcase value := <-dataCh:\n\t\t\t\t\tif value == MaxRandomNumber-1 {\n\t\t\t\t\t\t// the same trick is used to notify the moderator \n\t\t\t\t\t\t// to close the additional signal channel.\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase toStop <- "receiver#" + id:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tlog.Println(value)\n\t\t\t\t}\n\t\t\t}\n\t\t}(strconv.Itoa(i))\n\t}\n\n\t// ...\n\twgReceivers.Wait()\n\tlog.Println("stopped by", stoppedBy)\n}\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);